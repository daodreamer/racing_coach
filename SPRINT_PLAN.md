# AI赛车教练 — Sprint 开发计划

> **开发模式**：Agile + Sprint + TDD
> **Sprint 周期**：每个 Sprint 为 **1周（5个工作日）**
> **总计**：7 个 Sprint，覆盖 Phase 0 ~ Phase 3

---

## 全局开发规范

### TDD 流程（所有 Sprint 强制执行）

```
Red   → 先写失败的测试（明确期望行为）
Green → 写最少的代码让测试通过
Refactor → 重构代码，保持测试全绿
```

### 代码规范

- 测试框架：`pytest`
- 测试覆盖率要求：核心模块 ≥ 80%，工具/辅助模块 ≥ 60%
- 每个 PR 必须附带对应的测试用例，CI 全绿后方可合并
- 提交信息格式：`<type>(scope): <description>`，如 `feat(telemetry): add brake pressure parser`
- 分支策略：`main` 保护分支，功能分支 `feature/<sprint>-<task>` 命名

### Definition of Done（通用完成定义）

每个 Story/Task 必须同时满足以下条件才算完成：

- [ ] 所有验收标准逐条通过
- [ ] 对应的单元测试已编写且全绿
- [ ] 测试覆盖率达标
- [ ] 代码已通过 Review（或自审 checklist）
- [ ] 无 lint 错误（`ruff` 或 `flake8`）
- [ ] 相关文档/注释已更新（仅限公共 API 变更时）

---

## Sprint 0 — 项目脚手架与开发环境（Phase 0 前置）

**Sprint 目标**：搭建项目骨架、CI 流水线和开发环境，使后续 Sprint 可以立即进入 TDD 循环。

### 任务清单

| ID | 任务 | 验收标准 |
|----|------|----------|
| S0-1 | ~~初始化项目结构~~ | ~~`src/racing_coach/` 包结构存在；`pyproject.toml` 配置完成；`pytest` 可运行空测试套件并返回 exit code 0~~ |
| S0-2 | ~~配置开发工具链~~ | ~~`ruff`（lint）+ `pytest` + `pytest-cov` 已集成；运行 `pytest --cov` 可输出覆盖率报告~~ |
| S0-3 | ~~初始化 Git 仓库与分支策略~~ | ~~`main` 分支存在且受保护；`.gitignore` 包含 Python/IDE/SQLite 常见忽略项~~ |
| S0-4 | ~~建立 CI 流水线~~ | ~~GitHub Actions（或本地 pre-commit hook）：每次提交自动运行 lint + test；任一失败则阻止合并~~ |

### 验收检查点

```
[x] 在空项目中运行 `pytest` → 0 errors, 0 failures          ✅ 2026-02-23
[x] 在空项目中运行 `ruff check .` → 0 violations             ✅ 2026-02-23
[x] 提交一个故意失败的测试 → CI/hook 报红                      ✅ 2026-02-23 (pre-commit hook)
```

---

## Sprint 1 — 遥测数据采集（Phase 0）

**Sprint 目标**：打通从 ACC（Assetto Corsa Competizione）读取遥测数据的完整管道，能够以 ≥ 60Hz 采集核心参数并持久化存储。

### User Stories

#### ~~S1-US1：遥测连接与心跳~~

> 作为开发者，我需要连接 ACC 共享内存并检测模拟器运行状态，以便确认数据源可用。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~当 ACC 运行时，连接函数返回 `True`~~ | ~~单元测试：mock 共享内存，断言连接状态~~ |
| ~~当 ACC 未运行时，连接函数返回 `False` 且不抛异常~~ | ~~单元测试：mock 空内存，断言优雅降级~~ |
| ~~连接状态变化时触发回调通知~~ | ~~单元测试：注册回调，模拟连接/断开，断言回调被调用~~ |

#### ~~S1-US2：核心参数解析~~

> 作为开发者，我需要从遥测流中解析出核心驾驶参数，以便后续分析使用。

**必须解析的参数**：

| 参数 | 字段 | 单位 | 有效范围 |
|------|------|------|----------|
| 速度 | `speed` | m/s | ≥ 0 |
| 油门位置 | `throttle` | 0.0 ~ 1.0 | [0, 1] |
| 刹车位置 | `brake` | 0.0 ~ 1.0 | [0, 1] |
| 转向角 | `steering_angle` | radians | [-π, π] |
| 挡位 | `gear` | int | [-1, 7]（-1=倒挡, 0=空挡） |
| RPM | `rpm` | rev/min | ≥ 0 |
| 纵向G力 | `g_force_lon` | g | 实数 |
| 横向G力 | `g_force_lat` | g | 实数 |
| 赛道位置 | `lap_dist_pct` | 0.0 ~ 1.0 | [0, 1]（圈百分比） |
| 圈号 | `lap_number` | int | ≥ 0 |
| 圈时间 | `lap_time` | seconds | ≥ 0 |

| 验收标准 | 测试方法 |
|----------|----------|
| ~~解析器输出包含上表全部 11 个字段~~ | ~~单元测试：给定 mock 原始字节，断言输出 dict 包含所有键~~ |
| ~~每个字段值在有效范围内（越界数据被标记/钳位）~~ | ~~参数化测试：边界值、越界值、NaN 输入~~ |
| ~~解析单帧耗时 < 1ms~~ | ~~性能测试：`pytest-benchmark`，1000 次解析取 p99~~ |

#### ~~S1-US3：数据持久化~~

> 作为用户，我希望每圈的遥测数据被自动保存，以便赛后回看。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~每圈数据存入 SQLite，表结构包含 `session_id`, `lap_number`, `timestamp`, 及全部核心参数~~ | ~~单元测试：写入一圈数据后查询，断言行数 = 采样点数~~ |
| ~~支持按 `session_id + lap_number` 查询完整单圈数据~~ | ~~单元测试：写入多圈，查询指定圈，断言数据隔离正确~~ |
| ~~数据库文件 < 50MB / 100圈（iRacing 60Hz 标准采样）~~ | ~~集成测试：生成 100 圈模拟数据写入，检查文件大小~~ |

#### ~~S1-US4：.ibt 文件导入（已移除）~~

> ~~作为用户，即使不实时连接模拟器，我也能导入遥测文件进行分析。~~

**⚠️ 2026-02-24 移除**：此 Story 基于 iRacing .ibt 文件格式设计。迁移至 ACC 后，遥测通道改为 Windows 具名共享内存（`Local\acpmf_physics` / `Local\acpmf_graphics`），ACC 不提供 .ibt 格式。数据持久化通过 Sprint 1-US3 的 SQLite 录制实现，离线分析读取数据库而非文件。

### Sprint 1 验收检查点

```
[x] 运行采集脚本 → 控制台实时打印速度、踏板、转向等参数（人工验证）  ✅ 2026-02-24 (ACCLiveConnection + ACCParser + scripts/check_acc.py)
[x] 跑完一段 Session → SQLite 中有完整的逐帧数据                      ✅ 2026-02-23 (TelemetryStorage)
[x] ACC 真实数据验证：G值、速度、踏板数值与赛道行为一致               ✅ 2026-02-24 (实车测试通过)
[x] pytest 全绿，覆盖率 ≥ 80%                                         ✅ 2026-02-24 (173 tests, 93% coverage)
```

---

## Sprint 2 — 赛道建模与弯道分段（Phase 1a）

**Sprint 目标**：基于遥测位置数据，自动识别赛道上的弯道边界，为后续逐弯分析奠定基础。

### User Stories

#### ~~S2-US1：赛道中心线提取~~

> 作为系统，我需要从一组圈速数据中提取赛道中心线，作为弯道分段的基础。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~给定一圈的 `(lap_dist_pct, x, y)` 序列，输出平滑的赛道中心线坐标数组~~ | ~~单元测试：用已知赛道数据（如椭圆），断言输出点在合理范围内~~ |
| ~~中心线首尾相连形成闭合环路，起终点误差 < 1m~~ | ~~单元测试：断言首尾点距离 < 阈值~~ |
| ~~多圈数据输入时取平均值，消除单圈偏差~~ | ~~单元测试：给定含噪声的 3 圈数据，断言输出比任意单圈更平滑~~ |

#### ~~S2-US2：弯道自动检测~~

> 作为系统，我需要自动识别赛道上的弯道位置和类型。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~基于曲率阈值检测弯道，输出弯道列表：`[{id, entry_pct, apex_pct, exit_pct, direction}]`~~ | ~~单元测试：用已知赛道（如含 3 个弯的测试数据），断言检测到 3 个弯且方向正确~~ |
| ~~区分左弯（`L`）和右弯（`R`）~~ | ~~单元测试：构造对称的左/右弯数据，断言方向标注正确~~ |
| ~~直道不被误判为弯道~~ | ~~单元测试：纯直线数据输入，断言弯道列表为空~~ |
| ~~连续S弯被正确拆分为独立弯道~~ | ~~单元测试：构造S弯曲率序列，断言拆分为 2 个反向弯道~~ |

#### ~~S2-US3：弯道三段划分~~

> 作为系统，每个弯道需要被细分为入弯（Entry）、弯心（Apex）、出弯（Exit）三个阶段。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~每个弯道输出 `entry_start`, `entry_end/apex_start`, `apex_end/exit_start`, `exit_end` 四个位置标记~~ | ~~单元测试：给定弯道数据，断言四个标记单调递增~~ |
| ~~弯心区域包含曲率最大点~~ | ~~单元测试：断言曲率峰值在 `apex_start` 和 `apex_end` 之间~~ |
| ~~三段覆盖弯道全长，无重叠无遗漏~~ | ~~单元测试：断言 entry_start = 弯道起点, exit_end = 弯道终点，段之间无间隙~~ |

### Sprint 2 验收检查点

```
[x] 输入真实赛道数据（如 Spa-Francorchamps）→ 输出弯道列表与已知弯道数量基本一致  ✅ 2026-02-23 (CenterlineExtractor + CornerDetector)
[x] 每个弯道有明确的 Entry/Apex/Exit 三段标记                                       ✅ 2026-02-23 (Corner.apex_start / apex_end)
[x] pytest 全绿，覆盖率 ≥ 80%                                                        ✅ 2026-02-23 (78 tests, 96% coverage)
```

---

## Sprint 3 — 参考圈对比与错误检测（Phase 1b）

**Sprint 目标**：实现用户圈与参考圈的逐点对比，以及基于规则的常见驾驶错误检测。

### User Stories

#### ~~S3-US1：参考圈管理~~

> 作为用户，我希望能指定某一圈作为参考圈（个人最佳），后续圈速与之对比。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~可将任意已保存的圈标记为参考圈，存入数据库~~ | ~~单元测试：标记操作后查询，断言 `is_reference = True`~~ |
| ~~每个 赛道+车辆 组合最多保存一个活跃参考圈~~ | ~~单元测试：连续标记两圈为参考圈，断言仅最新的一圈生效~~ |
| ~~自动选择模式：将历史最快圈自动设为参考圈~~ | ~~单元测试：插入 5 圈不同用时，断言最快圈被自动选中~~ |

#### ~~S3-US2：逐点 Delta 计算~~

> 作为系统，我需要计算用户圈与参考圈在每个采样点上的时间差（Delta）。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~基于 `lap_dist_pct` 对齐两圈数据，计算逐点 Delta（秒）~~ | ~~单元测试：构造两圈已知数据，手动计算期望 Delta，断言匹配（误差 < 10ms）~~ |
| ~~两圈采样率不同时，通过插值对齐~~ | ~~单元测试：一圈 60Hz 一圈 30Hz，断言 Delta 计算不报错且结果合理~~ |
| ~~输出逐弯 Delta 汇总：`[{corner_id, delta_entry, delta_apex, delta_exit, delta_total}]`~~ | ~~单元测试：给定含 3 弯的数据，断言输出 3 条弯道汇总~~ |
| ~~正值表示比参考圈慢，负值表示更快~~ | ~~单元测试：构造一圈全程快于参考圈的数据，断言所有 Delta < 0~~ |

#### ~~S3-US3：刹车分析~~

> 作为系统，我需要检测每个弯道的刹车行为并与参考圈对比。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~检测刹车起始点（brake > 阈值的第一帧），与参考圈刹车点的距离差以米为单位输出~~ | ~~单元测试：构造已知刹车数据，断言距离差计算正确~~ |
| ~~检测刹车峰值压力及达到峰值的时间~~ | ~~单元测试：构造刹车曲线，断言峰值和时间点正确~~ |
| ~~识别"循迹刹车"质量：刹车释放是否平滑线性递减~~ | ~~单元测试：构造线性释放 vs 突然释放，断言评分差异~~ |
| ~~检测轮胎抱死事件（刹车压力高但速度骤降异常）~~ | ~~单元测试：构造抱死特征数据，断言被检测到~~ |

#### ~~S3-US4：油门分析~~

> 作为系统，我需要检测出弯阶段的油门使用质量。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~检测油门施加点（弯心后 throttle > 阈值的第一帧）~~ | ~~单元测试：构造已知油门数据，断言油门点位置正确~~ |
| ~~检测"过早全油门"：油门 100% 时转向角仍大于阈值~~ | ~~单元测试：构造过早全油门场景，断言被标记~~ |
| ~~检测油门/刹车重叠（滑行）：同时 brake > 0.05 且 throttle > 0.05~~ | ~~单元测试：构造重叠帧和正常帧，断言仅重叠帧被标记~~ |

#### ~~S3-US5：弯心速度分析~~

> 作为系统，我需要评估弯心区域的最低速度。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~提取弯心区域最低速度 $V_{min}$ 并与参考圈对比~~ | ~~单元测试：构造已知数据，断言 $V_{min}$ 提取和差值正确~~ |
| ~~弯心速度低于参考圈超过阈值（如 5 km/h）时标记为"弯心过慢"~~ | ~~参数化测试：差值 3/5/10 km/h，断言仅 ≥ 阈值被标记~~ |

### Sprint 3 验收检查点

```
[x] 输入两圈真实数据 → 输出逐弯 Delta 时间汇总表                          ✅ 2026-02-23 (DeltaCalculator)
[x] 每个弯道有刹车/油门/弯心三维度的具体诊断信息                           ✅ 2026-02-23 (BrakingAnalyzer + ThrottleAnalyzer + ApexSpeedAnalyzer)
[x] 已知错误场景（晚刹车、早油门、抱死）全部被正确检测                      ✅ 2026-02-23 (all error detection tests pass)
[x] pytest 全绿，覆盖率 ≥ 80%                                             ✅ 2026-02-23 (129 tests, 96% coverage)
```

---

## Sprint 4 — 分析报告与 LLM 反馈生成（Phase 2a）

**Sprint 目标**：将 Sprint 2-3 的结构化分析结果通过 LLM 转换为自然语言建议，生成完整的单圈分析报告。

### User Stories

#### ~~S4-US1：结构化分析结果聚合~~

> 作为系统，我需要将弯道分段、Delta、错误检测的结果聚合为一份结构化报告对象。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~报告对象包含：总 Delta、逐弯 Delta Top 3（时间损失最大的弯道）、每弯的错误列表~~ | ~~单元测试：给定模拟分析结果，断言报告结构完整~~ |
| ~~错误按时间影响降序排列（影响最大的排第一）~~ | ~~单元测试：给定多个错误及其 Delta，断言排序正确~~ |
| ~~报告可序列化为 JSON~~ | ~~单元测试：`json.dumps(report)` 不报错，`json.loads` 后数据不丢失~~ |

#### ~~S4-US2：LLM Prompt 工程~~

> 作为系统，我需要将结构化报告转换为 LLM 可理解的 Prompt，生成专业且可操作的建议。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~Prompt 模板包含：系统角色设定、结构化数据注入槽位、输出格式约束~~ | ~~单元测试：检查模板渲染后包含关键占位符替换~~ |
| ~~Prompt 明确要求 LLM 不得编造数据中不存在的信息（防幻觉指令）~~ | ~~单元测试：断言 Prompt 包含防幻觉约束关键词~~ |
| ~~生成的 Prompt token 数 < 2000（控制成本）~~ | ~~单元测试：字符估算法验证 10 弯场景 token < 2000~~ |

#### ~~S4-US3：LLM 调用与响应解析~~

> 作为系统，我需要调用 LLM API 并将响应解析为结构化的建议列表。API使用Moonshot AI的kimi k2.5. API Key通过环境变量 `MOONSHOT_API_KEY` 注入。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~成功调用 LLM API 并获取文本响应~~ | ~~集成测试（可 mock）：断言返回非空字符串~~ |
| ~~API 超时（> 10s）或失败时返回预设的 fallback 建议（基于规则引擎的纯文本）~~ | ~~单元测试：mock API 超时，断言返回 fallback 且不抛异常~~ |
| ~~响应解析为 `[{corner_id, severity, suggestion}]` 列表~~ | ~~单元测试：给定已知 LLM 响应文本，断言解析结果结构正确~~ |
| ~~单次 API 调用成本记录到日志~~ | ~~单元测试：mock API 响应含 usage 字段，断言日志中有成本记录~~ |

#### ~~S4-US4：分析报告输出~~

> 作为用户，我需要看到一份完整的文字分析报告。

| 验收标准 | 测试方法 |
|----------|----------|
| ~~报告包含：总结概要（1-2句）、逐弯详细分析、优先改进建议（Top 3）~~ | ~~单元测试：断言报告输出包含必要段落标题~~ |
| ~~报告可导出为 Markdown 格式文件~~ | ~~单元测试：输出文件是合法的 Markdown（标题、列表结构完整）~~ |
| ~~端到端流程：`ACC 录制会话数据 → 分析 → 报告` 可在单条命令中完成~~ | ~~集成测试：给定测试录制数据，运行 CLI 命令，断言输出报告文件存在且非空~~ |

### Sprint 4 验收检查点

```
[x] 输入一段 ACC 录制数据 → 运行一条命令 → 生成 Markdown 分析报告   ✅ 2026-02-24 (scripts/record_session.py + scripts/analyze_session.py，kimi-k2.5 LLM 成功生成逐弯中文建议，9弯 +0.762s Delta)
[x] 报告中的建议与实际数据一致（无 LLM 幻觉的明显痕迹）                ✅ 2026-02-23 (anti-hallucination prompt + rule fallback)
[x] LLM 不可用时，fallback 报告仍可生成                                ✅ 2026-02-23 (fallback_suggestions + summary)
[x] pytest 全绿，覆盖率 ≥ 80%                                         ✅ 2026-02-24 (179 tests, 93% coverage)
```

---

## Sprint 5 — Web UI 与进步追踪（Phase 2b）

**Sprint 目标**：提供一个可视化界面，展示分析报告和用户历史进步趋势。

### User Stories

#### ~~S5-US1：Web 服务框架~~

> ~~作为开发者，我需要一个轻量级 Web 服务来承载 UI 和 API。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~FastAPI 应用启动后，`GET /health` 返回 `200 OK`~~ | ~~集成测试：`TestClient` 请求，断言状态码~~ |
| ~~`POST /api/analyze` 接受 JSON body（引用本地 `db_path`），返回分析报告 JSON~~ | ~~集成测试：mock service，断言响应包含 `analysis_id`、`corners` 和 `summary` 字段~~ |
| ~~`GET /api/laps?track=xxx&car=xxx` 返回历史圈速列表~~ | ~~集成测试：mock storage，断言返回列表长度正确~~ |

#### ~~S5-US2：分析报告页面~~

> ~~作为用户，我需要一个可视化页面查看单圈分析结果。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~页面展示赛道地图，弯道区域用颜色标注（绿 = 快于参考圈，红 = 慢于参考圈）~~ | ~~HTML 测试：断言 response.text 包含 `trackMap` canvas 元素~~ |
| ~~页面展示逐弯 Delta 柱状图~~ | ~~HTML 测试：断言 response.text 包含 `deltaChart` canvas 元素~~ |
| ~~页面展示 LLM 生成的文字建议~~ | ~~HTML 测试：断言 response.text 包含 summary 文本内容~~ |

#### ~~S5-US3：进步趋势追踪~~

> ~~作为用户，我希望看到自己在某赛道上的历史进步趋势。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~折线图展示同一赛道+车辆组合的历史圈速变化~~ | ~~HTML 测试：预置历史数据，断言 response.text 包含 `trendChart` 元素~~ |
| ~~历史表格展示多圈的进步轨迹及查看报告链接~~ | ~~HTML 测试：断言 response.text 包含 `View` 链接~~ |
| ~~支持日期范围过滤（Python 端过滤，无 JS）~~ | ~~`GET /progress?date_from=...&date_to=...` 由服务端过滤数据~~ |

### Sprint 5 验收检查点

```
[x] 浏览器打开 Web UI → POST /api/analyze → 返回 analysis_id + 可视化报告页       ✅ 2026-02-25
[x] 历史趋势页面 /progress 展示折线图 + 历史表格 + 日期过滤                        ✅ 2026-02-25
[x] 所有 API 端点有对应的集成测试且全绿（27 个新增测试）                           ✅ 2026-02-25
[x] pytest 全绿，覆盖率 ≥ 70%（web 模块 96–98%，总体 94%）                        ✅ 2026-02-25 (206 tests)
[x] ruff check . → 0 errors                                                          ✅ 2026-02-25
```

---

## Sprint 6 — 实时热路径（Phase 3a）

**Sprint 目标**：实现低延迟的本地实时反馈通道，在驾驶中提供刹车点提示音等即时反馈。

### User Stories

#### ~~S6-US1：实时遥测事件流~~

> ~~作为系统，我需要将实时遥测数据转换为事件流，供热路径规则引擎消费。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~遥测读取线程以 ≥ 60Hz 发布事件到内部队列~~ | ~~单元测试：mock 数据源，运行 1 秒后断言队列中有 ≥ 55 个事件~~ |
| ~~事件包含时间戳，且相邻事件时间差 < 20ms（60Hz）~~ | ~~单元测试：检查队列中连续事件的时间戳差~~ |
| ~~队列满时丢弃最旧事件（不阻塞生产者）~~ | ~~单元测试：将队列容量设为 10，推入 20 个事件，断言无阻塞且队列保留最新 10 个~~ |

#### ~~S6-US2：刹车点提示音~~

> ~~作为用户，当我接近某个弯道的参考刹车点时，我希望听到一个提示音帮助我判断刹车时机。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~当 `lap_dist_pct` 进入参考刹车点前 50m 范围时，触发音频提示~~ | ~~单元测试：模拟位置序列经过刹车点，断言触发事件被发出~~ |
| ~~提示音从事件触发到音频播放的延迟 < 50ms~~ | ~~性能测试：记录事件时间戳和音频回调时间戳，断言差值 < 50ms~~ |
| ~~同一弯道在同一圈内不重复触发~~ | ~~单元测试：模拟车辆在刹车点附近来回（如弯道中减速），断言仅触发一次~~ |
| ~~提示音音量和音调可配置~~ | ~~单元测试：传入不同配置参数，断言生成的音频参数不同~~ |

#### ~~S6-US3：实时错误警报~~

> ~~作为用户，当我发生轮胎抱死或 TC 介入时，我希望立刻收到警报。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~轮胎抱死事件在发生后 100ms 内触发音频警报~~ | ~~性能测试：mock 抱死数据注入，测量检测延迟~~ |
| ~~同类警报有冷却期（3秒内不重复触发同一类型）~~ | ~~单元测试：连续注入抱死事件，断言 3 秒内仅触发一次~~ |

### Sprint 6 验收检查点

```
[x] ACC 中驾驶 → 接近弯道时听到刹车点双短音提示（人工验证）  ✅ 2026-02-25
[x] 刹车抱死时听到单长音警报（人工验证）                      ✅ 2026-02-25
[x] 端到端延迟 < 100ms（daemon 线程 + queue，无阻塞）         ✅ 2026-02-25
[x] pytest 全绿，15 个新增测试，覆盖率 ≥ 80%                  ✅ 2026-02-25 (221 tests)
```

---

## Sprint 7 — TTS 语音反馈与 Overlay（Phase 3b）

**Sprint 目标**：实现温路径的语音反馈和游戏内视觉覆盖层，完成实时 AI 教练的完整体验闭环。

### User Stories

#### ~~S7-US1：弯道评语语音播报~~

> ~~作为用户，每过完一个弯道后，我希望听到一句简短的语音评语。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~车辆驶出弯道 exit 点后 2 秒内，触发 TTS 语音播报~~ | ~~集成测试：模拟弯道出口事件，断言 TTS 调用在 2s 内发出~~ |
| ~~评语基于该弯道的实时分析结果（如 "Turn 3: 刹车点不错，但出弯油门可以更早"）~~ | ~~单元测试：给定分析结果，断言生成的文本包含弯道编号和具体建议~~ |
| ~~连续弯道间强制 3 秒静默期（不应期）~~ | ~~单元测试：两个弯道出口事件间隔 1 秒，断言第二条评语被延迟~~ |
| ~~高优先级警报（如抱死）可打断当前评语~~ | ~~单元测试：评语播放中注入高优先级事件，断言当前评语被中断~~ |

#### ~~S7-US2：TTS 引擎集成~~

> ~~作为系统，我需要将文本快速转换为语音并播放。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~TTS 生成延迟（文本输入到音频开始播放）< 500ms~~ | ~~性能测试：测量从调用到首字节音频的时间~~ |
| ~~支持至少一个 TTS 后端（如本地 `pyttsx3` 或云端 ElevenLabs）~~ | ~~集成测试：调用 TTS 接口，断言返回可播放的音频数据~~ |
| ~~TTS 后端不可用时静默降级（不阻塞主流程）~~ | ~~单元测试：mock TTS 失败，断言无异常，主事件循环正常~~ |

#### ~~S7-US3：游戏内 Overlay~~

> ~~作为用户，我希望在游戏画面上看到实时的 Delta 时间和踏板对比信息。~~

| 验收标准 | 测试方法 |
|----------|----------|
| ~~透明窗口 Always-on-Top 覆盖在游戏画面上~~ | ~~手动验收：游戏全屏时 Overlay 可见~~ |
| ~~实时显示当前 Delta 时间（相对参考圈的累计时间差）~~ | ~~手动验收：对比 Overlay 数值与赛后报告的 Delta~~ |
| ~~显示用户踏板输入 vs 参考圈踏板输入的对比条~~ | ~~手动验收：踩刹车时对比条实时变化~~ |
| ~~Overlay 刷新率 ≥ 30fps，不引起游戏掉帧（CPU 占用 < 5%）~~ | ~~性能测试：`psutil` 监控进程 CPU 使用率~~ |

### Sprint 7 验收检查点

```
[x] ACC 中驾驶 → 过弯后听到语音评语（人工验证）           ✅ 2026-02-25 (Win32TTSEngine SAPI5 direct，过弯评语正常播报)
[x] Overlay 显示实时 Delta 和踏板对比（人工验证）          ✅ 2026-02-25 (tkinter always-on-top 透明窗口，踏板对比条实时更新)
[x] 高密度弯道路段不出现语音堆积（人工验证）               ✅ 2026-02-25 (3秒静默期 + 每圈每弯唯一 key 去重)
[x] 语音不可用时系统仍正常运行（降级测试）                 ✅ 2026-02-25 (--no-tts 使用 NullTTSEngine，win32com 不可用时静默降级)
[x] pytest 全绿，覆盖率 ≥ 75%                             ✅ 2026-02-25 (260 tests, 87% coverage)
```

---

## 附录 A：Sprint 总览与里程碑

```
Sprint 0  项目脚手架        ──┐
Sprint 1  遥测数据采集       ──┤── Phase 0: 数据流打通
                              │
Sprint 2  赛道建模与弯道分段  ──┤
Sprint 3  参考圈对比与错误检测 ──┤── Phase 1: 核心分析引擎
                              │
Sprint 4  LLM 反馈生成       ──┤
Sprint 5  Web UI 与进步追踪  ──┤── Phase 2: 赛后分析 MVP ★ 用户可用
                              │
Sprint 6  实时热路径         ──┤
Sprint 7  TTS 与 Overlay    ──┘── Phase 3: 实时 AI 教练
```

**关键里程碑**：Sprint 5 完成后即为**可交付的 MVP**。此时用户可以上传 ACC 录制的遥测数据获取 AI 分析报告。Sprint 6-7 为增强功能，需在 MVP 验证核心价值后再启动。

## 附录 B：测试金字塔目标

```
              ┌─────────┐
              │  E2E    │  ← 少量：ACC 录制 → 报告端到端
             ─┼─────────┼─
            │ Integration │ ← 中量：API、DB、LLM mock
           ─┼─────────────┼─
          │   Unit Tests    │ ← 大量：解析器、算法、规则
         ─┴─────────────────┴─
```

| 层级 | 占比目标 | 运行频率 |
|------|----------|----------|
| Unit | ~70% | 每次提交 |
| Integration | ~20% | 每次 PR |
| E2E | ~10% | 每个 Sprint 结束 |

## 附录 C：技术栈速查

| 模块 | 技术 | 备注 |
|------|------|------|
| 语言 | Python 3.11+ | MVP 阶段唯一语言 |
| 测试 | pytest + pytest-cov + pytest-benchmark | TDD 核心工具 |
| Lint | ruff | 替代 flake8 + isort + black |
| 数据库 | SQLite | 零部署，`sqlite3` 标准库 |
| 遥测 SDK | ctypes + mmap（stdlib） | ACC Windows 具名共享内存，无第三方依赖 |
| Web 框架 | FastAPI + Uvicorn | 轻量高性能 |
| 前端 | HTMX + Chart.js（或纯 Jinja2 模板） | 极简前端，避免 SPA 复杂度 |
| LLM | Moonshot AI Kimi k2.5（`api.moonshot.ai`，国际版） | API Key 通过 `MOONSHOT_API_KEY` 环境变量注入；OpenAI 兼容接口 |
| TTS | pyttsx3（本地）/ ElevenLabs（云端） | Sprint 7 引入 |
| Overlay | PyQt6 / tkinter（透明窗口） | Sprint 7 引入 |
